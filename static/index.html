<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Public Speaking Assessment</title>
<style>
/* Keep your existing styles (body, container, upload section, results, etc.) */
</style>
</head>
<body>
<div class="container">
    <!-- Upload Section -->
    <div id="uploadView">
        <div class="header">
            <h1>Master Your Voice ðŸ“£</h1>
            <p class="analyzed-date">Upload a video to analyze your speaking skills</p>
        </div>
        <div class="upload-section" id="dropZone">
            <div style="font-size: 3em; margin-bottom: 20px;">ðŸ“¹</div>
            <p style="margin-bottom: 20px; font-size: 1.1em; color: #86868b;">
                Upload your video (MP4, WebM, MOV)
            </p>
            <p style="margin-bottom: 20px; font-size: 0.95em; color: #0071e3; font-weight: 600;">
                ðŸ“¹ Upload videos up to 3 minutes (we'll compress large files automatically)
            </p>
            <input type="file" id="videoInput" accept="video/*">
            <button class="upload-btn" onclick="document.getElementById('videoInput').click()">
                Choose Video
            </button>
            <div class="filename" id="filename"></div>
        </div>
    </div>

    <!-- Processing Section -->
    <div class="processing" id="processing">
        <div class="spinner"></div>
        <p style="color: #1d1d1f; font-size: 1.1em;">Processing your video...</p>
        <p style="color: #86868b; margin-top: 10px;">This may take 30-60 seconds</p>
    </div>

    <!-- Results -->
    <div class="results" id="results">
        <!-- Keep your existing results HTML (tabs, transcript, metrics) -->
    </div>
</div>

<script type="module">
import { createFFmpeg, fetchFile } from 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.0/dist/ffmpeg.min.js';

const API_URL = window.location.origin;
const ffmpeg = createFFmpeg({ log: true });

let videoFile = null;

// Drag & drop and input handlers
const dropZone = document.getElementById('dropZone');
['dragenter','dragover','dragleave','drop'].forEach(evt =>
    dropZone.addEventListener(evt, e => { e.preventDefault(); e.stopPropagation(); }, false)
);
['dragenter','dragover'].forEach(evt =>
    dropZone.addEventListener(evt, () => dropZone.classList.add('drag-over'))
);
['dragleave','drop'].forEach(evt =>
    dropZone.addEventListener(evt, () => dropZone.classList.remove('drag-over'))
);

dropZone.addEventListener('drop', e => handleFile(e.dataTransfer.files[0]));
document.getElementById('videoInput').addEventListener('change', e => handleFile(e.target.files[0]));

async function handleFile(file) {
    if (!file.type.startsWith('video/')) {
        alert('Please upload a valid video file (MP4, WebM, MOV).');
        return;
    }

    videoFile = file;
    const fileSizeMB = file.size / (1024*1024);

    // Check video duration
    const duration = await getVideoDuration(file);
    if (duration > 180) {
        alert(`Video too long (${(duration/60).toFixed(1)} min). Please use a video under 3 minutes.`);
        return;
    }

    document.getElementById('filename').textContent = `${file.name} (${fileSizeMB.toFixed(1)}MB)`;

    // Compress if file is bigger than ~20MB
    if (fileSizeMB > 20) {
        document.getElementById('filename').textContent += " - Compressing...";
        file = await compressVideo(file);
        const compressedSizeMB = file.size / (1024*1024);
        document.getElementById('filename').textContent = `${file.name} (compressed ${compressedSizeMB.toFixed(1)}MB)`;
    }

    processVideo(file);
}

function getVideoDuration(file) {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.preload = 'metadata';
        video.src = URL.createObjectURL(file);
        video.onloadedmetadata = () => {
            resolve(video.duration);
            URL.revokeObjectURL(video.src);
        };
        video.onerror = () => reject('Error loading video');
    });
}

async function compressVideo(file) {
    if (!ffmpeg.isLoaded()) {
        await ffmpeg.load();
    }

    const inputName = 'input.mp4';
    const outputName = 'output.mp4';

    ffmpeg.FS('writeFile', inputName, await fetchFile(file));

    // Compress: 720p, ~1.5Mbps, mono audio 64k
    await ffmpeg.run(
        '-i', inputName,
        '-vf', 'scale=w=1280:h=-2',
        '-b:v', '1500k',
        '-c:v', 'libx264',
        '-preset', 'fast',
        '-c:a', 'aac',
        '-b:a', '64k',
        '-movflags', '+faststart',
        outputName
    );

    const data = ffmpeg.FS('readFile', outputName);
    return new File([data.buffer], file.name.replace(/\.\w+$/, '.mp4'), { type: 'video/mp4' });
}

async function processVideo(file) {
    document.getElementById('uploadView').style.display = 'none';
    document.getElementById('processing').style.display = 'block';

    const videoURL = URL.createObjectURL(file);
    document.getElementById('videoOnly').src = videoURL;
    document.getElementById('audioOnly').src = videoURL;

    try {
        const formData = new FormData();
        formData.append('video', file);

        const response = await fetch(`${API_URL}/analyze`, { method: 'POST', body: formData });
        if (!response.ok) {
            const err = await response.json().catch(() => ({ error: 'Unknown error' }));
            throw new Error(err.error || `Server error: ${response.status}`);
        }

        const data = await response.json();
        displayResults(data);
    } catch (err) {
        console.error(err);
        alert(`Error: ${err.message}`);
        resetApp();
    }
}

// Keep your displayResults, highlightFillerWords, generateWordCloud, switchTab, resetApp functions here
</script>
</body>
</html>
